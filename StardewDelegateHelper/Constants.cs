namespace StardewDelegateHelper;

internal static class Constants {

	public const string IModManifest = "StardewModdingAPI.IManifest";
	public const string IModHelper = "StardewModdingAPI.IModHelper";


	public const string Header = @"//-----------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Leclair.StardewDelegateHelper
//     source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated for any reason.
// </auto-generated>
//-----------------------------------------------------------------------------

#nullable enable";

	public const string ExcludeCodeCoverage = @"[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = ""Generated by the Leclair.StardewDelegateHelper source generator."")]";
	public const string ExcludeEditorBrowseable = @"[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]";

	public const string Helpers = $@"

{ExcludeEditorBrowseable}
{ExcludeCodeCoverage}
internal static class SDHInternal {{

    internal record struct ModData(string UniqueID, string? MinVersion = null, string? MaxVersion = null, bool IsInverted = false);

	internal static bool CheckModVersions({IModHelper} helper, params ModData[] modData) {{
		if (modData.Length == 0)
			return true;

		foreach (var mod in modData) {{
			var metadata = helper.ModRegistry.Get(mod.UniqueID);
			bool isLoaded;
			if (metadata is not null) {{
				isLoaded = true;
				if (mod.MinVersion != null || mod.MaxVersion != null) {{
					var version = metadata.Manifest.Version;
					var verString = version.ToString();
					isLoaded = version.IsBetween(mod.MinVersion ?? verString, mod.MaxVersion ?? verString);
				}}
			}} else
				isLoaded = false;

			if (isLoaded == mod.IsInverted)
				return false;
		}}

		return true;
	}}

}}
";

	public const string Attributes = $@"/// <summary>
/// Methods decorated with this attribute will be automatically mapped to
/// the relevant event within a generated <c>RegisterEvents()</c> method
/// on their containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method)]
{ExcludeCodeCoverage}
public class SMAPIEventAttribute : global::System.Attribute {{ }}

/// <summary>
/// Methods decorated with this attribute will be registered via the
/// game's <see cref=""TriggerActionManager.RegisterAction"" /> method
/// within a generated <c>RegisterTriggerActions()</c> method on their
/// containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class TriggerActionAttribute : global::System.Attribute {{

	public string? Name {{ get; }}

	public bool IncludePrefix {{ get; }}

	/// <param name=""name"">The name to register this trigger action with. If this is null, we'll use the method's name.</param>
	/// <param name=""includePrefix"">Whether or not the name should be prefixed when registering this trigger action.</param>
	public TriggerActionAttribute(string? name = null, bool includePrefix = true) {{
		Name = name;
		IncludePrefix = includePrefix;
	}}
}}

/// <summary>
/// Methods decorated with this attribute will be registered via the
/// game's <see cref=""GameStateQuery.Register"" /> method
/// within a generated <c>RegisterGSQConditions()</c> method on their
/// containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class GSQConditionAttribute : global::System.Attribute {{

	public string? Name {{ get; }}

	public bool IncludePrefix {{ get; }}

	/// <param name=""name"">The name to register this GSQ condition with. If this is null, we'll use the method's name.</param>
	/// <param name=""includePrefix"">Whether or not the name should be prefixed when registering this GSQ condition.</param>
	public GSQConditionAttribute(string? name = null, bool includePrefix = true) {{
		Name = name;
		IncludePrefix = includePrefix;
	}}
}}

/// <summary>
/// Methods decorated with this attribute will be registered via the
/// game's <see cref=""ItemQueryResolver.Register"" /> method
/// within a generated <c>RegisterItemResolvers()</c> method on their
/// containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class ItemResolverAttribute : global::System.Attribute {{

	public string? Name {{ get; }}

	public bool IncludePrefix {{ get; }}

	/// <param name=""name"">The name to register this item resolver with. If this is null, we'll use the method's name.</param>
	/// <param name=""includePrefix"">Whether or not the name should be prefixed when registering this item resolver.</param>
	public ItemResolverAttribute(string? name = null, bool includePrefix = true) {{
		Name = name;
		IncludePrefix = includePrefix;
	}}
}}

/// <summary>
/// Methods decorated with this attribute will be registered via the
/// game's <see cref=""GameLocation.RegisterTileAction"" /> method
/// within a generated <c>RegisterTileActions()</c> method on their
/// containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class TileActionAttribute : global::System.Attribute {{

	public string? Name {{ get; }}

	public bool IncludePrefix {{ get; }}

	/// <param name=""name"">The name to register this tile action with. If this is null, we'll use the method's name.</param>
	/// <param name=""includePrefix"">Whether or not the name should be prefixed when registering this tile action.</param>
	public TileActionAttribute(string? name = null, bool includePrefix = true) {{
		Name = name;
		IncludePrefix = includePrefix;
	}}
}}

/// <summary>
/// Methods decorated with this attribute will be registered via the
/// game's <see cref=""GameLocation.RegisterTouchAction"" /> method
/// within a generated <c>RegisterTouchActions()</c> method on their
/// containing class.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class TouchActionAttribute : global::System.Attribute {{

	public string? Name {{ get; }}

	public bool IncludePrefix {{ get; }}

	/// <param name=""name"">The name to register this touch action with. If this is null, we'll use the method's name.</param>
	/// <param name=""includePrefix"">Whether or not the name should be prefixed when registering this touch action.</param>
	public TouchActionAttribute(string? name = null, bool includePrefix = true) {{
		Name = name;
		IncludePrefix = includePrefix;
	}}
}}


/// <summary>
/// Methods decorated with this attribute will only be registered with
/// whatever appropriate registry they've been attributed with if the
/// specified mod is loaded.
///
/// Adding this to something may result in the signature of the relevant
/// registration method changing due to the need to consult SMAPI's
/// mod registry to read mod state.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class IfModLoadedAttribute : global::System.Attribute {{

	public string UniqueID {{ get; }}
	public string? MinVersion {{ get; }}
	public string? MaxVersion {{ get; }}

	/// <param name=""uniqueID"">The unique ID of the mod to check for. This is required.</param>
	/// <param name=""minVersion"">The minimum version of the mod that satisfies our condition.</param>
	/// <param name=""maxVersion"">The maximum version of the mod that satisfies our condition.</param>
	public IfModLoadedAttribute(string uniqueID, string? minVersion = null, string? maxVersion = null) {{
		UniqueID = uniqueID;
		MinVersion = minVersion;
		MaxVersion = maxVersion;
	}}
}}


/// <summary>
/// Methods decorated with this attribute will only be registered with
/// whatever appropriate registry they've been attributed with if the
/// specified mod is not loaded.
///
/// Adding this to something may result in the signature of the relevant
/// registration method changing due to the need to consult SMAPI's
/// mod registry to read mod state.
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=true)]
{ExcludeCodeCoverage}
public class IfNotModLoadedAttribute : global::System.Attribute {{

	public string UniqueID {{ get; }}
	public string? MinVersion {{ get; }}
	public string? MaxVersion {{ get; }}

	/// <param name=""uniqueID"">The unique ID of the mod to check for. This is required.</param>
	/// <param name=""minVersion"">The minimum version of the mod that satisfies our condition.</param>
	/// <param name=""maxVersion"">The maximum version of the mod that satisfies our condition.</param>
	public IfNotModLoadedAttribute(string uniqueID, string? minVersion = null, string? maxVersion = null) {{
		UniqueID = uniqueID;
		MinVersion = minVersion;
		MaxVersion = maxVersion;
	}}
}}

";

}
